# hello算法(一)

「算法 algorithm」<https://www.hello-algo.com/>

## 迭代与递归



### 迭代

「迭代 iteration」"自下而上" 累加或者重复基础步骤

在满足一定条件下重复进行某段代码,直到条件不再满足.

**`for` 循环的代码更加紧凑，`while` 循环更加灵活**，两者都可以实现迭代结构.

1. for循环

   预先知道迭代次数

2. while循环

   自由度高于for循环

3. 循环结构中嵌套另一个循环结构

### 递归

「递归 recursion」"自上而下" 分解问题为子问题,该子问题跟原问题有相同的形式,直到基本情况停止(基本情况解已知)

通过函数调用自身来解决问题

1. **递**：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。

2. **归**：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

   //新奇的专业解释(我第一次真正分清楚这两个字的内在含义)

在实际中,编程语言允许的递归深度通常是有限的,**过深的递归可能导致栈溢出错误.**

#### 尾递归

在函数返回的最后一步才用递归调用,则该函数可以被编译器或解释器优化,使其在空间效率上与迭代相当.这种情况被称为「尾递归 tail recursion」

//请注意，许多编译器或解释器并不支持尾递归优化。例如，Python 默认不支持尾递归优化，因此即使函数是尾递归形式，仍然可能会遇到栈溢出问题。

[2.2  迭代与递归 - Hello 算法 (hello-algo.com)](https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion/#2)

```
/* 尾递归 */
function tailRecur(n, res) {
    // 终止条件
    if (n === 0) return res;
    // 尾递归调用
    return tailRecur(n - 1, res + n);
}
//神!
```

尾递归的核心在我个人理解当中是在"递"的过程中就执行求值操作,不再"归"

#### 递归树

![斐波那契数列的递归树](./hello算法(一).assets/recursion_tree.png)

### 算法空间

//以下是原话

算法在运行过程中使用的内存空间主要包括以下几种。

- **输入空间**：用于存储算法的输入数据。
- **暂存空间**：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
- **输出空间**：用于存储算法的输出数据。

一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

暂存空间可以进一步划分为三个部分。

- **暂存数据**：用于保存算法运行过程中的各种常量、变量、对象等。
- **栈帧空间**：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
- **指令空间**：用于保存编译后的程序指令，在实际统计中通常忽略不计。